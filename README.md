# MongoDB Context

This package fills a gap in the MongoDB driver by providing a convenient way to create a unified context for database access. It allows you to register a single object within your application, making it easier to interact with the database without worrying about table names, schema configurations, connection strings, and other low-level details.

**⚠️ This project is currently used in production across several internal applications without issues. However, please use it with caution — we are planning a refactor to enhance its resilience and expand its functionality.** 

## Compatibilities and driver version

| Version | .NET SDK       | MongoDB* | MongoDB Driver |
|---------|----------------|----------|----------------|
| 1.9     | netstandard2.0 | 7, 8     | 3              |

*this version is included in our integration tests. You may try connecting to other compatible driver versions, but stability and compatibility are not guaranteed. 

## Examples

A running example of the usage is [this test project](https://github.com/fmisrl/mongo-dbcontext/tree/master/tests/FmiSrl.MongoDbContext.SourceGenerator.Tests) inside the test folder.

## Installation

You need to reference two projects:

```
dotnet add package FmiSrl.MongoDbContext.Abstractions
dotnet add package FmiSrl.MongoDbContext.SourceGenerator
```

The `FmiSrl.MongoDbContext.Abstractions` project contains all the abstraction layer and base functionalities for the db context.
The `FmiSrl.MongoDbContext.SourceGenerator` project contains the source generator for generating the specialized code for your db context.


## Usage

As usual, create your database layer models, keep in mind, that if the model is a root class with an id and not a nested object you should inherit from `IAggregateRoot` (in the next versions this requirement will be removed). 

```csharp
public class TestObject : IAggregateRoot
{
    [BsonId(IdGenerator = typeof(StringObjectIdGenerator))]
    public string? Id { get; set; } = null!;
    
    public string Name { get; set; } = null!;
}
```

---

Create an interface that inherits from `IDbContext` with all your collections like that.

```csharp
public interface ITestDbContext : IDbContext
{
    [Collection("Test_Objects")]
    IMongoCollection<TestObject> TestObjects { get; }
    
    IMongoCollection<TestGenericObject<string>> TestGenericObjects { get; }
    
    string GetEmptyString { get; }

    string GetHelloString();
}
```

As you can see, every collection is registered with type `IMongoCollection<T>` where `T` is the type of your object. If you do not provide collection's name with the `[Collection("<name>")]` attribute, the name of the property was used.

You can place your own methods and properties in the interface to implement it later, they are ignored by the generator.

---

Create a partial class that implements the interface.

```csharp
public partial class TestDbContext : ITestDbContext
{
    public string GetEmptyString => string.Empty;

    public string GetHelloString()
    {
        return "Say Hello!";
    }
}
```

You must implement yourself all the methods and properties that are not generated by the generator.
The code behind the collection properties will be generated by the source generator.

--- 

Now you can create a connection to your database and use it directly in your application.

```csharp
const string connectionString = "mongodb://mongoadmin:mysupersecretpassword@localhost:27017";
const string databaseName = "test";

var dbContext = new TestDbContext(); 
dbContext.OpenConnection(connectionString, databaseName);
```

or share it using the dependency injection.

```csharp
builder.Services.AddSingleton<ITestDbContext, TestDbContext>(dbContext);
```